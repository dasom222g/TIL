### Context

LLM 에이전트를 n8n 워크플로우로 구축할 때, LLM이 복잡하거나 긴 프롬프트에 응답하면서 JSON 출력 형식을 완벽하게 준수하지 못하는 경우가 빈번하게 발생했습니다. 특히 응답 앞뒤에 불필요한 설명 텍스트나 깨진 마크다운 펜스(```json)가 포함되어, 후속 노드의 JSON 파싱(JSON Parse) 작업에서 시스템 에러가 발생하며 워크플로우가 중단되는 문제가 발생했습니다.

초기에는 프롬프트에 Few-shot 예제를 추가하여 LLM의 구조 준수율을 높이려 했으나, 근본적인 해결책이 되지 못했습니다. 이에 따라, AI의 응답을 그대로 신뢰하는 대신, 결정론적인 **n8n 코드 노드(Code Node)**를 활용하여 정규표현식(Regex)으로 1차 정제하는 방어적 프로그래밍 전략을 채택했습니다.

### Core

다음 코드는 n8n의 **코드 노드(Code Node)**에 삽입되어, LLM 응답 문자열에서 유효한 JSON 객체를 감싸는 `{`와 `}` 사이의 문자열만 추출하여 불필요한 텍스트를 제거하고 파싱 안정성을 높이는 방법을 보여줍니다.

```javascript
// LLM 응답을 포함하는 입력 항목을 가정
const llmOutput = $input.item.json.llmResponse;

// 정규 표현식을 사용하여 첫 번째 '{'에서 시작하여 마지막 '}'로 끝나는 문자열을 추출
// /\{[\s\S]*\}/: 첫 번째 '{'부터 마지막 '}'까지 모든 문자(줄 바꿈 포함)를 탐욕적으로 매칭하여 전체 JSON 객체를 캡처합니다.
const jsonMatch = llmOutput.match(/\{[\s\S]*\}/);

if (jsonMatch) {
  // 추출된 문자열의 양쪽 공백 제거
  const cleanString = jsonMatch[0].trim();
  
  try {
    // 정제된 문자열을 JSON 객체로 파싱
    const parsedJson = JSON.parse(cleanString);
    // 다음 노드로 파싱된 JSON 객체를 전달
    return [{ json: parsedJson }];
  } catch (e) {
    // JSON 파싱 실패 시 (디버깅용 정보 포함)
    return [{
      json: {
        error: "Parsing failed after regex extraction",
        raw_output: llmOutput
      }
    }];
  }
} else {
  // JSON 구조를 찾지 못한 경우
  return [{
    json: {
      error: "No JSON structure found",
      raw_output: llmOutput
    }
  }];
}
```

### Insight

이 경험을 통해 AI 에이전트 구축 시 시스템의 안정성을 확보하는 핵심 원칙을 재확인했습니다. LLM의 구조적 출력에 대한 의존도를 낮추고, 결정론적인 코드(정규표현식, 하드 코딩된 로직)를 중간 단계에 배치하여 AI의 비결정성(Non-determinism)을 제어해야 합니다. 

*   'Few-shot' 학습은 유용하지만, 이는 LLM의 *의도*를 높이는 것이지 *보장*하는 것이 아닙니다. 
*   반면, n8n의 **코드 노드**를 사용한 정규표현식 처리는 LLM 출력의 외부 노이즈(extraneous text)를 제거하는 데 있어 높은 신뢰도를 제공합니다. 

이는 모든 작업을 AI에게 맡기려는 '나태함' 대신, 시스템 엔지니어링 관점에서 데이터 유효성 검증(Data Validation) 단계를 추가하는 것이 장기적인 시스템 안정화에 필수적임을 시사합니다.

**출처:** [Use a Function Node to Clean JSON/Markdown](https://community.n8n.io/t/use-a-function-node-to-clean-json-markdown/28435)